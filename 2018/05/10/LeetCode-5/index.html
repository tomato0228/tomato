<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> LeetCode_5_最长回文子串 · Tomato Blog</title><meta name="description" content="I have no idea how long I can keep working on that. The only thing I hope is that it can record every detail in my life, and create stories for my-future-self."><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2018/05/10/LeetCode-5/" class="post-title-link">LeetCode_5_最长回文子串</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/算法/" class="post-tag-link">算法</a></li><li class="post-tag-item"><a href="/tags/LeetCode/" class="post-tag-link">LeetCode</a></li></ul><div class="post-time">Thursday, May 10th 2018</div></div><div class="post-content"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener"><code>最长回文子串</code></a> <a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener"><code>Longest Palindromic Substring</code></a></p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>给定一个字符串 <strong>s</strong>，找到 <strong>s</strong> 中最长的回文子串。你可以假设 <strong>s</strong> 的最大长度为1000。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Tags</strong>: 字符串，动态规划</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>解决此题思路主要用了 <a href="https://www.cnblogs.com/love-yh/p/7072161.html" target="_blank" rel="noopener"><code>Manacher&#39;s Algorithm ----马拉车算法</code></a></p>
<h3 id="马拉车算法："><a href="#马拉车算法：" class="headerlink" title="马拉车算法："></a>马拉车算法：</h3><h4 id="改造字符串-S"><a href="#改造字符串-S" class="headerlink" title="改造字符串 S"></a>改造字符串 S</h4><p>首先用一个非常巧妙的方式，将所有可能的奇数和偶数长度的回文子串都转换成了奇数长度：在每个字符的两边都插入一个特殊的符号。比如： <code>abba --&gt; #a#b#b#a#</code> <code>aba  --&gt; #a#b#a#</code><br>为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如 <code>$#a#b#a#</code> （注意，下面的代码是用 C 语言编写，由于C语言规范还要求字符串末尾有一个’\0’所以正好OK，但其他语言可能会导致越界）。</p>
<p>以 <code>abaaba</code> 例：<code>T = &quot;$#a#b#a#a#b#a#&quot;</code></p>
<h4 id="数组-P-的作用"><a href="#数组-P-的作用" class="headerlink" title="数组 P 的作用"></a>数组 P 的作用</h4><p>为了改进回文相互重叠的情况，我们将改造完后的 T[ i ] 处的回文半径存储到数组 P[ ] 中，P[ i ] 为新字符串T的 T[ i ] 处的回文半径（表示以字符 T[ i ] 为中心的最长回文字串的最端右字符到 T[ i ] 的长度），如以 T[ i ] 为中心的最长回文子串的为 T[ l, r ]，那么 P[ i ] = r - i + 1。这样最后遍历数组 P[ ]，取其中最大值即可。若 P[ i ] = 1 表示该回文串就是 T[ i ] 本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index |  1   2   3   4   5   6   7   8   9   10  11  12  13</span><br><span class="line">  T   |  #   a   #   b   #   a   #   a   #   b   #   a   #  </span><br><span class="line">  P   |  1   2   1   4   1   2   7   2   1   4   1   2   1</span><br></pre></td></tr></table></figure>
<p><strong>划重点：P[ i ] - 1 正好是原字符串中回文串的总长度</strong></p>
<p>数组 P 有一性质，P[ i ] - 1 就是该回文子串在原字符串 S 中的长度 ，那就是 P[ i ] - 1 就是该回文子串在原字符串 S 中的长度。<br><strong>证明：</strong>首先在转换得到的字符串 T 中，所有的回文字串的长度都为奇数，那么对于以 T[ i ] 为中心的最长回文字串，其长度就为 2 * P[ i ] - 1,经过观察可知，T 中所有的回文子串，其中分隔符的数量一定比其他字符的数量多 1，也就是有 P[ i ] 个分隔符，剩下 P[ i ] - 1 个字符来自原字符串，所以该回文串在原字符串中的长度就为 P[ i ] - 1。</p>
<h4 id="计算数组-P"><a href="#计算数组-P" class="headerlink" title="计算数组 P"></a>计算数组 P</h4><p>那么怎么计算P[i]呢？该算法增加两个辅助变量（其实一个就够了，两个更清晰）id 和 mx，其中 id 为已知的 {右边界最大} 的回文子串的<strong>中心</strong>，mx 则为 id + P[ id ]，也就是这个回文子串的右边界。</p>
<p>然后可以得到一个非常神奇的结论，这个算法的关键点就在这里了：如果 <code>mx &gt; i</code> ，那么 P[ i ] &gt;= MIN(P[2 * id - i], mx - i)。把它写得复杂一点，理解起来会简单很多：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记j = 2 * id - i，也就是说 j 是 i 关于 id 的对称点(j = id - (i - id))</span></span><br><span class="line"><span class="keyword">if</span> (P[j] &gt; mx - i) &#123;</span><br><span class="line">    P[i] = P[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">/* P[j] &gt;= mx - i */</span></span><br><span class="line">    P[i] = mx - i; </span><br><span class="line">    <span class="comment">// P[i] &gt;= mx - i，取最小值，之后再匹配更新（其实后面不会再匹配了，下面会详解）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 <code>mx &lt; i</code> 时 <code>P[i]</code> 再匹配更新。</p>
<h5 id="计算过程解释"><a href="#计算过程解释" class="headerlink" title="计算过程解释"></a>计算过程解释</h5><ol>
<li><code>mx &gt; i</code> 时如何计算 P[ i ] 的值？毫无疑问的是数组 P 中点 i 之前点对应的值都已经计算出来了。利用回文串的特性，我们找到点 i 关于 id 的对称点 j ，其值为 j = 2 * id - i 。因为点 j 、i 在以 id 为中心的最大回文串的范围内（[L ,R]）其中 L = id - (mx - id) , R = mx。<ol>
<li>那么如果 P[ j ] &lt; R - i （同样是 L 和 j 之间的距离），说明，以点 j 为中心的回文串没有超出范围 [L , R]，由回文串的特性可知，从左右两端向 id 遍历，两端对应的字符都是相等的。所以P[ j ] = P[ i ]（这里得先从点 j 转到点 i  的情况），如下图：<br> <img src="https://images2015.cnblogs.com/blog/1168728/201706/1168728-20170624150751538-286806776.png" alt=""></li>
<li>如果P[ j ] &gt;= R - i （即 j 为中心的回文串的最左端超过 L），如下图所示。即，以点 j为中心的最大回文串的范围已经超出了范围[L ,R] ，这种情况，等式P[ j ] = P[ i ]还成立吗？显然是不成立的！因，以点 j 为中心的回文串的最左端超过 L，那么在[L, j]之间的字符肯定能在(j, id]找到相等的，由回文串的特性可知，P[ i ] 等于 R- i，至于是否大于 R - i（图中红色的部分），肯定不会，如果大于 R - i 那么以 id 为中心的回文串就大于 mx，若图中的红色部分是 i 的回文，则肯定和 j 那边对应，增长 id 回文长度，所以从 R + 1 开始匹配，R + 1 就会失配，为了代码书写简单，就让他继续匹配，而不用引入新的分支进行判断。<br> <img src="https://images2015.cnblogs.com/blog/1168728/201706/1168728-20170624164713366-717289734.png" alt=""></li>
</ol>
</li>
<li><code>i &gt; mx</code> 时，如下图。这种情况，没法利用到回文串的特性，只能老老实实的一步步去匹配。<br> <img src="https://images2015.cnblogs.com/blog/1168728/201706/1168728-20170624171657601-779083481.png" alt=""></li>
</ol>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">"$"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">            t = t + <span class="string">"#"</span> + s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        t = t + <span class="string">"#\0"</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(t.length() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, reId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; t[i] != <span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">            p[i] = mx &gt; i ? min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) &#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; mx) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[reId] &lt; p[i]) &#123;</span><br><span class="line">                reId = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr((reId - p[reId]) / <span class="number">2</span>, p[reId] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div></article><div class="pagination"><a href="/2018/05/10/LeetCode-6/" class="pagination-prev">PREV</a><a href="/2018/05/09/LeetCode-4/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/LeetCode-13/">LeetCode_13_罗马数字转整数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/LeetCode-11/">LeetCode_11_盛最多水的容器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/LeetCode-9/">LeetCode_9_回文数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/LeetCode-8/">LeetCode_8_字符串转整数 (atoi)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/LeetCode-7/">LeetCode_7_反转整数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/LeetCode-350/">LeetCode_350_两个数组的交集 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/LeetCode-136/">LeetCode_136_只出现一次的数字</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/LeetCode-217/">LeetCode_217_存在重复元素</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2018 <a href="/">Tomato</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body></html>