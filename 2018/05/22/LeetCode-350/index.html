<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> LeetCode_350_两个数组的交集 II · Tomato Blog</title><meta name="description" content="I have no idea how long I can keep working on that. The only thing I hope is that it can record every detail in my life, and create stories for my-future-self."><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2018/05/22/LeetCode-350/" class="post-title-link">LeetCode_350_两个数组的交集 II</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/算法/" class="post-tag-link">算法</a></li><li class="post-tag-item"><a href="/tags/LeetCode/" class="post-tag-link">LeetCode</a></li></ul><div class="post-time">Tuesday, May 22nd 2018</div></div><div class="post-content"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/description/" target="_blank" rel="noopener"><code>两个数组的交集 II</code></a> <a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/description/" target="_blank" rel="noopener"><code>Intersection of Two Arrays II</code></a></p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>给定两个数组，写一个方法来计算它们的交集。</p>
<p><strong>例如:</strong></p>
<p>给定 nums1 = <strong>[1, 2, 2, 1]</strong>, nums2 = <strong>[2, 2]</strong>, 返回 <strong>[2, 2]</strong>.</p>
<p><strong>注意：</strong></p>
<ul>
<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<p><strong>跟进:</strong></p>
<ul>
<li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li>
<li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li>
<li>如果nums2的元素存储在磁盘上，内存是有限的，你不能一次加载所有的元素到内存中，你该怎么办？</li>
</ul>
<p><strong>Tags</strong>: 排序, 哈希表, 双指针, 二分查找</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>利用HashMap，遍历nums1，将nums1里面的数以(num, count)保存，num为出现的数，count为出现的次数。<br>然后再遍历nums2，如果map中num的count大于0，则将count减 1 ，将num存入result结果中。</p>
<ul>
<li>如果nums2的元素存储在磁盘上，而内存是有限的，不能同时将所有元素加载到内存中，会发生什么情况呢?<ul>
<li>如果只有nums2不能装入内存，将nums1的所有元素放入HashMap中，读取与内存匹配的数组块，并记录这些交集。</li>
</ul>
</li>
<li>如果nums1和nums2都是如此巨大，它们都不适合内存，那么就分别对它们进行排序(外部排序)，然后在内存中一次读取每个数组中的两个元素，记录交集。</li>
</ul>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(nums1.empty() || nums2.empty())</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m : nums1) &#123;</span><br><span class="line">            <span class="built_in">map</span>[m] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[m] != <span class="number">0</span>)&#123;</span><br><span class="line">                result.push_back(m);</span><br><span class="line">                <span class="built_in">map</span>[m] --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div></article><div class="pagination"><a href="/2018/05/25/LeetCode-7/" class="pagination-prev">PREV</a><a href="/2018/05/22/LeetCode-136/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/LeetCode-13/">LeetCode_13_罗马数字转整数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/LeetCode-11/">LeetCode_11_盛最多水的容器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/LeetCode-9/">LeetCode_9_回文数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/LeetCode-8/">LeetCode_8_字符串转整数 (atoi)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/LeetCode-7/">LeetCode_7_反转整数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/LeetCode-350/">LeetCode_350_两个数组的交集 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/LeetCode-136/">LeetCode_136_只出现一次的数字</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/LeetCode-217/">LeetCode_217_存在重复元素</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2018 <a href="/">Tomato</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>