<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tomato Blog</title>
  
  <subtitle>The days of Tomato and Readmore</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.readmore.ltd/"/>
  <updated>2018-05-25T16:33:49.562Z</updated>
  <id>http://www.readmore.ltd/</id>
  
  <author>
    <name>Tomato</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode_13_罗马数字转整数</title>
    <link href="http://www.readmore.ltd/2018/05/25/LeetCode-13/"/>
    <id>http://www.readmore.ltd/2018/05/25/LeetCode-13/</id>
    <published>2018-05-25T10:50:37.000Z</published>
    <updated>2018-05-25T16:33:49.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/roman-to-integer/description/" target="_blank" rel="noopener"><code>罗马数字转整数</code></a> <a href="https://leetcode.com/problems/roman-to-integer/description/" target="_blank" rel="noopener"><code>. Roman to Integer</code></a></p><p>罗马数字包含以下七种字符：<code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><p><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。<br><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。<br><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: C = 100, L = 50, XXX = 30, III = 3.</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 数学, 字符串</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'I'</span> : </span><br><span class="line">                    <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                        result += <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">switch</span> (s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'V'</span> : result += <span class="number">4</span>; i++; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'X'</span> : result += <span class="number">9</span>; i++; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>  : result += <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'V'</span> : </span><br><span class="line">                    result += <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'X'</span> : </span><br><span class="line">                    <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                        result += <span class="number">10</span>;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">switch</span> (s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'L'</span> : result += <span class="number">40</span>; i++; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'C'</span> : result += <span class="number">90</span>; i++; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>  : result += <span class="number">10</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'L'</span> : </span><br><span class="line">                    result += <span class="number">50</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'C'</span> : </span><br><span class="line">                    <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                        result += <span class="number">100</span>;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">switch</span> (s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'D'</span> : result += <span class="number">400</span>; i++; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'M'</span> : result += <span class="number">900</span>; i++; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>  : result += <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'D'</span> : </span><br><span class="line">                    result += <span class="number">500</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'M'</span> : </span><br><span class="line">                    result += <span class="number">1000</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: assert(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/roman-to-integer/des
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="简单" scheme="http://www.readmore.ltd/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_11_盛最多水的容器</title>
    <link href="http://www.readmore.ltd/2018/05/25/LeetCode-11/"/>
    <id>http://www.readmore.ltd/2018/05/25/LeetCode-11/</id>
    <published>2018-05-25T10:25:23.000Z</published>
    <updated>2018-05-25T10:56:54.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/container-with-most-water/description/" target="_blank" rel="noopener"><code>盛最多水的容器</code></a> <a href="https://leetcode.com/problems/container-with-most-water/description/" target="_blank" rel="noopener"><code>Container With Most Water</code></a></p><p>给定 $n$ 个非负整数 $a_1，a_2，…，a_n$，每个数代表坐标中的一个点 $(i, a_i)$ 。画 $n$ 条垂直线，使得垂直线 $i$ 的两个端点分别为 $(i, a_i)$ 和 $(i, 0)$。找出其中的两条线，使得它们与 $x$ 轴共同构成的容器可以容纳最多的水。</p><p><strong>注意：</strong>你不能倾斜容器，$n$ 至少是 $2$。</p><p><strong>Tags</strong>: 数组, 双指针</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p><strong>算法：</strong>使用两个指针分别指向数组的头和尾。指向的值较小的那个指针移动，即左指针右移，右指针左移。并保存最大盛水量。当左右指针相遇时，指针停止移动，得到的最大盛水量即为所求。</p><p><strong>假设法证明：</strong></p><ul><li><strong>假设：</strong>该算法并没有遍历到容量最大的情况</li><li>我们令容量最大时的指针为 <code>max_left</code> 和 <code>max_right</code></li><li>根据题设，我们可以假设遍历时左指针先到达 <code>max_left</code></li><li>但是当左指针为 <code>max_left</code> 时，右指针还没有经过 <code>max_right</code> 左指针就移动了</li><li>已知当左指针停留在 <code>max_left</code> 时，它只有在两种场景下会发生改变<ul><li>左指针和右指针在 <code>max_left</code> 相遇，则右指针一定在前往 <code>max_left</code> 的途中经过 <code>max_right</code>，与题设 <strong>矛盾</strong></li><li>右指针位于 <code>max_right</code> 右侧且当前的值大于左指针。则在这种情况下，此时容器的盛水量比题设中最大的盛水量还要大，与题设 <strong>矛盾</strong></li></ul></li><li><strong>因此</strong>该算法的遍历一定经过了最大的盛水量的情况</li></ul><p><em>感谢<a href="https://segmentfault.com/a/1190000008824222" target="_blank" rel="noopener"><code>raledong</code></a>的证明，原文<a href="raledong">链接</a></em></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxWater = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            maxWater = max(maxWater, min(height[left], height[right]) * (right - left));</span><br><span class="line">            height[left] &gt; height[right] ? right-- : left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="中等" scheme="http://www.readmore.ltd/categories/LeetCode/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_9_回文数</title>
    <link href="http://www.readmore.ltd/2018/05/25/LeetCode-9/"/>
    <id>http://www.readmore.ltd/2018/05/25/LeetCode-9/</id>
    <published>2018-05-25T07:39:48.000Z</published>
    <updated>2018-05-25T07:46:50.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/palindrome-number/description/" target="_blank" rel="noopener"><code>回文数</code></a> <a href="https://leetcode.com/problems/palindrome-number/description/" target="_blank" rel="noopener"><code>Palindrome Number</code></a></p><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>你能不将整数转为字符串来解决这个问题吗？</p><p><strong>Tags</strong>: 数学</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>将x倒叙存入（详见代码）另一个变量a，判断a是否等于x即可，不需要判断溢出，因为a等于x。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( x &gt;= <span class="number">10</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = x;</span><br><span class="line">            <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                a = a * <span class="number">10</span> + b % <span class="number">10</span>;</span><br><span class="line">                b /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (a == x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-number/de
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="简单" scheme="http://www.readmore.ltd/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_8_字符串转整数 (atoi)</title>
    <link href="http://www.readmore.ltd/2018/05/25/LeetCode-8/"/>
    <id>http://www.readmore.ltd/2018/05/25/LeetCode-8/</id>
    <published>2018-05-25T07:33:39.000Z</published>
    <updated>2018-05-25T07:40:15.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/description/" target="_blank" rel="noopener"><code>字符串转整数 (atoi)</code></a> <a href="https://leetcode.com/problems/string-to-integer-atoi/description/" target="_blank" rel="noopener"><code>String to Integer (atoi)</code></a></p><p>实现 <code>atoi</code>，将字符串转为整数。<br>在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。<br>当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。<br>若函数不能执行有效的转换，返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位有符号整数，其数值范围是 $[−2^{31},  2^{31} − 1]$。如果数值超过可表示的范围，则返回  INT_MAX $(2^{31} − 1)$ 或 INT_MIN $(−2^{31})$ 。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 数学, 字符串</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>解决思路和第七题类似，主要是溢出判断。详情见第七题（LeetCode_7_反转整数）</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>, base = <span class="number">0</span>, i = <span class="number">0</span>, n = str.size();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; str[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = (str[i++] == <span class="string">'+'</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (base != (base * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>)) / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (sign == <span class="number">1</span>) ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            base = <span class="number">10</span> * base + (str[i++] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> base * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/string-to-integer-at
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="中等" scheme="http://www.readmore.ltd/categories/LeetCode/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_7_反转整数</title>
    <link href="http://www.readmore.ltd/2018/05/25/LeetCode-7/"/>
    <id>http://www.readmore.ltd/2018/05/25/LeetCode-7/</id>
    <published>2018-05-25T07:14:32.000Z</published>
    <updated>2018-05-25T07:32:07.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/reverse-integer/description/" target="_blank" rel="noopener"><code>反转整数</code></a> <a href="https://leetcode.com/problems/reverse-integer/description/" target="_blank" rel="noopener"><code>Reverse Integer</code></a></p><p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>假设我们的环境只能存储 32 位有符号整数，其数值范围是 $[−2^{31},  2^{31} − 1]$。根据这个假设，如果反转后的整数溢出，则返回 0。</p><p><strong>Tags</strong>: 数学</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>result来存储中间的结果，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (result != (result * <span class="number">10</span> + num % <span class="number">10</span>) / <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要是验证是否超过最大整数范围<br>如：x = 2147483647 ；当result = 746384741时，num = 2，此时result <em> 10 + num % 10超过了int的最大整数2147483647，者(result </em> 10 + num % 10) / 10不再为746384741。</p><p>加 num % 10 在这可以不用加，因为加 0 和 加 num % 10一样，如果加0 每溢出，而加num % 10溢出，在此处是不可能的，如：当result = 214748364，加 0 不会溢出，反而如果加 8 则会溢出，但是反过来想，这种情况发生时 x = 846384741，本身就是溢出的，所以你懂的。（第八题判断溢出就必须要加，因为第八题x是字符串输入的不会溢出，哈哈哈哈）。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = x &gt; <span class="number">0</span> ? x : -x;</span><br><span class="line">        <span class="keyword">while</span> ( num != <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result != (result * <span class="number">10</span> + num % <span class="number">10</span>) / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result *= x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-integer/desc
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="简单" scheme="http://www.readmore.ltd/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_350_两个数组的交集 II</title>
    <link href="http://www.readmore.ltd/2018/05/22/LeetCode-350/"/>
    <id>http://www.readmore.ltd/2018/05/22/LeetCode-350/</id>
    <published>2018-05-21T16:51:41.000Z</published>
    <updated>2018-05-23T01:50:54.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/description/" target="_blank" rel="noopener"><code>两个数组的交集 II</code></a> <a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/description/" target="_blank" rel="noopener"><code>Intersection of Two Arrays II</code></a></p><p>给定两个数组，写一个方法来计算它们的交集。</p><p><strong>例如:</strong></p><p>给定 nums1 = <strong>[1, 2, 2, 1]</strong>, nums2 = <strong>[2, 2]</strong>, 返回 <strong>[2, 2]</strong>.</p><p><strong>注意：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong>跟进:</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li><li>如果nums2的元素存储在磁盘上，内存是有限的，你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><p><strong>Tags</strong>: 排序, 哈希表, 双指针, 二分查找</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>利用HashMap，遍历nums1，将nums1里面的数以(num, count)保存，num为出现的数，count为出现的次数。<br>然后再遍历nums2，如果map中num的count大于0，则将count减 1 ，将num存入result结果中。</p><ul><li>如果nums2的元素存储在磁盘上，而内存是有限的，不能同时将所有元素加载到内存中，会发生什么情况呢?<ul><li>如果只有nums2不能装入内存，将nums1的所有元素放入HashMap中，读取与内存匹配的数组块，并记录这些交集。</li></ul></li><li>如果nums1和nums2都是如此巨大，它们都不适合内存，那么就分别对它们进行排序(外部排序)，然后在内存中一次读取每个数组中的两个元素，记录交集。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(nums1.empty() || nums2.empty())</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m : nums1) &#123;</span><br><span class="line">            <span class="built_in">map</span>[m] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[m] != <span class="number">0</span>)&#123;</span><br><span class="line">                result.push_back(m);</span><br><span class="line">                <span class="built_in">map</span>[m] --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="简单" scheme="http://www.readmore.ltd/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_136_只出现一次的数字</title>
    <link href="http://www.readmore.ltd/2018/05/22/LeetCode-136/"/>
    <id>http://www.readmore.ltd/2018/05/22/LeetCode-136/</id>
    <published>2018-05-21T16:44:25.000Z</published>
    <updated>2018-05-21T16:49:46.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/single-number/description/" target="_blank" rel="noopener"><code>只出现一次的数字</code></a> <a href="https://leetcode.com/problems/single-number/description/" target="_blank" rel="noopener"><code>Single Number</code></a></p><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br><strong>说明：</strong><br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 位运算, 哈希表</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>因为不使用额外的空间，考虑位运算，两个相同的数异或为0，则将数组所有数异或后得到的结果为只出现一次的数，出现两次的数都异或为0了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xorRes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            xorRes ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xorRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/single-number/descri
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="简单" scheme="http://www.readmore.ltd/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_217_存在重复元素</title>
    <link href="http://www.readmore.ltd/2018/05/22/LeetCode-217/"/>
    <id>http://www.readmore.ltd/2018/05/22/LeetCode-217/</id>
    <published>2018-05-21T16:34:08.000Z</published>
    <updated>2018-05-21T16:43:40.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/contains-duplicate/description/" target="_blank" rel="noopener"><code>存在重复元素</code></a> <a href="https://leetcode.com/problems/contains-duplicate/description/" target="_blank" rel="noopener"><code>Contains Duplicate</code></a></p><p>给定一个整数数组，判断是否存在重复元素。<br>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 数组, 哈希表</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>定义一个set，遍历数组，如果set里面没有当前数，则把当前数放入set中，否则返回true，遍历完后，说明没有重复的则返回false。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(n) == s.end()) &#123;</span><br><span class="line">                s.insert(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/contains-duplicate/d
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="简单" scheme="http://www.readmore.ltd/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_122_买卖股票的最佳时机 II</title>
    <link href="http://www.readmore.ltd/2018/05/22/LeetCode-122/"/>
    <id>http://www.readmore.ltd/2018/05/22/LeetCode-122/</id>
    <published>2018-05-21T16:25:08.000Z</published>
    <updated>2018-05-21T16:37:29.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener"><code>买卖股票的最佳时机 II</code></a> <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener"><code>Best Time to Buy and Sell Stock II</code></a></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 贪心算法, 数组</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>相邻两天的差值如果是正值就加起来，如果是负值就加0，最后结果就是最大的利益。由给个例题推敲一下就可以得出规律。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            profits += max(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="简单" scheme="http://www.readmore.ltd/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_26_删除排序数组中的重复项</title>
    <link href="http://www.readmore.ltd/2018/05/22/LeetCode-26/"/>
    <id>http://www.readmore.ltd/2018/05/22/LeetCode-26/</id>
    <published>2018-05-21T16:07:42.000Z</published>
    <updated>2018-05-21T16:37:32.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener"><code>删除排序数组中的重复项</code></a> <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener"><code>Remove Duplicates from Sorted Array</code></a></p><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以 <strong>“引用”</strong> 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 数组, 双指针</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>思路很清晰，从头开始遍历，定义i、j。<br>i是循环数组的，j是指向当前不重复的数组长度，当i每找到一个执行 <code>nums[j++] = nums[i];</code> 就行</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-fr
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="简单" scheme="http://www.readmore.ltd/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_36_有效的数独</title>
    <link href="http://www.readmore.ltd/2018/05/11/LeetCode-36/"/>
    <id>http://www.readmore.ltd/2018/05/11/LeetCode-36/</id>
    <published>2018-05-11T14:13:49.000Z</published>
    <updated>2018-05-21T16:08:49.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/valid-sudoku/description/" target="_blank" rel="noopener"><code>有效的数独</code></a> <a href="https://leetcode.com/problems/valid-sudoku/description/" target="_blank" rel="noopener"><code>Valid Sudoku</code></a></p><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="有效的数独"><br>上图是一个部分填充的有效的数独。<br>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: false</span><br><span class="line">解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。</span><br><span class="line">     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><p><strong>Tags</strong>: 哈希表</p><h2 id="思路-0"><a href="#思路-0" class="headerlink" title="思路 0"></a>思路 0</h2><p>先附上我的渣渣思路，主要看思路 1 ，超级赞。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>渣渣方法，三次全循环，第一循环查看行是否是有效的数独，第二循环查看列是否是有效的数独，第三循环查看以粗实线分隔的 <code>3x3</code> 宫内是否是有效的数独。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><code>C++</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">9</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; exist(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; length + <span class="number">1</span>; t++) &#123;</span><br><span class="line">                exist[t] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (exist[board[i][j] - <span class="string">'0'</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    exist[board[i][j] - <span class="string">'0'</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; length + <span class="number">1</span>; t++) &#123;</span><br><span class="line">                exist[t] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[j][i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (exist[board[j][i] - <span class="string">'0'</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    exist[board[j][i] - <span class="string">'0'</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">3</span>; h++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; length + <span class="number">1</span>; t++) &#123;</span><br><span class="line">                    exist[t] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = k * <span class="number">3</span>; i &lt; <span class="number">3</span> * k + <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = h * <span class="number">3</span>; j &lt;  <span class="number">3</span> * h + <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (exist[board[i][j] - <span class="string">'0'</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            exist[board[i][j] - <span class="string">'0'</span>] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h2><p>非常牛的一个思路，借助set容器来实现。</p><h3 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h3><p><code>&#39;4&#39; 在第 7 行</code> 将他存储为 <code>&quot;4 in row 7&quot;</code>.<br><code>&#39;4&#39; 在第 7 列</code> 将他存储为 <code>&quot;4 column 7&quot;</code>.<br><code>&#39;4&#39; 在最右上角的块里</code> 将他存储为 <code>&quot;4 in block 0-2&quot;</code>.<br>如果在集合里面有相同的数据，则表示重复出现，返回 <code>false</code> 。</p><p>比如在第 <code>7 行</code>出现第一个 <code>4</code> 时，在集合里面存入 <code>&quot;4 in row 7&quot;</code> ，然后又出现一个 <code>4</code> 时，<code>&quot;4 in row 7&quot;</code> 已经在集合里，就可以判定为是有效的数独，返回 <code>false</code>。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p><code>Java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        Set seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">char</span> number = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (number != <span class="string">'.'</span>)</span><br><span class="line">                    <span class="keyword">if</span> (!seen.add(number + <span class="string">" in row "</span> + i) ||</span><br><span class="line">                        !seen.add(number + <span class="string">" in column "</span> + j) ||</span><br><span class="line">                        !seen.add(number + <span class="string">" in block "</span> + i/<span class="number">3</span> + <span class="string">"-"</span> + j/<span class="number">3</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-sudoku/descrip
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="中等" scheme="http://www.readmore.ltd/categories/LeetCode/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_189_旋转数组</title>
    <link href="http://www.readmore.ltd/2018/05/11/LeetCode-189/"/>
    <id>http://www.readmore.ltd/2018/05/11/LeetCode-189/</id>
    <published>2018-05-11T03:08:23.000Z</published>
    <updated>2018-05-21T16:08:58.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/rotate-array/description/" target="_blank" rel="noopener"><code>旋转数组</code></a> <a href="https://leetcode.com/problems/rotate-array/description/" target="_blank" rel="noopener"><code>Rotate Array</code></a></p><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的原地算法。</li></ul><p><strong>Tags</strong>: 数组</p><h2 id="思路-0"><a href="#思路-0" class="headerlink" title="思路 0"></a>思路 0</h2><p>思路 0，是一个比较傻的方法，完全是投机取巧，基于 vector 的动态性质来的，对于练习题来说，这种方法个人不太推荐，得不到什么锻炼。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>vector 的 push_back 和erase 可以很容易的实现。<br>如例一，将开始的，1234放入vector后面，然后将前面的1234删掉，当然也可以边放在后面边删除前面的。详情见代码。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || nums.size() &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k = nums.size() - (k % nums.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            nums.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        nums.erase(nums.begin(),nums.begin()+k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h2><p>采用交换的方法，一种暴力的方法，比较简单。</p><h3 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h3><p><strong>开始 ：</strong><br>begin = 0, tIndex = 0, 都是 nums 的下标;<br>t = nums[tIndex], count = 0; count是控制循环的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例一为例，采用思路 1 的方法数组 nums 的变化过程如下：</span><br><span class="line">1 2 3 4 5 6 7   tIndex = 0, t = 1, count = 0</span><br><span class="line">1 2 3 1 5 6 7   tIndex = 3, t = 4, count = 1</span><br><span class="line">1 2 3 1 5 6 4   tIndex = 6, t = 7, count = 2</span><br><span class="line">1 2 7 1 5 6 4   tIndex = 2, t = 3, count = 3</span><br><span class="line">1 2 7 1 5 3 4   tIndex = 5, t = 6, count = 4</span><br><span class="line">1 6 7 1 5 3 4   tIndex = 1, t = 2, count = 5</span><br><span class="line">1 6 7 1 2 3 4   tIndex = 4, t = 5, count = 6</span><br><span class="line">5 6 7 1 2 3 4   tIndex = 0, t = 1, count = 7;count == nums.size()</span><br></pre></td></tr></table></figure><p>表示所有的数都已经交换，则停止循环<br>若 tIndex == begin 且 count == nums.size() 表示当前分组交换完毕，但是并不是所有数都交换，则 begin ++, tIndex ++, t = nums[tIndex] 继续交换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">需要begin ++, tIndex ++, t = nums[tIndex]继续交换的例子：</span><br><span class="line">nums[] = [1, 2, 3, 4, 5, 6], k = 2;</span><br><span class="line">1 2 3 4 5 6   tIndex = 0, t = 1, count = 0, begin = 0</span><br><span class="line">1 2 1 4 5 6   tIndex = 2, t = 3, count = 1, begin = 0</span><br><span class="line">1 2 1 4 3 6   tIndex = 4, t = 5, count = 2, begin = 0</span><br><span class="line">5 2 1 4 3 6   tIndex = 0, t = 1, count = 3, begin = 0</span><br><span class="line">              tIndex == begin, 则begin ++, tIndex ++, t = nums[tIndex]</span><br><span class="line">              ==&gt; begin = 1, tIndex = 1, t = 2, count = 3</span><br><span class="line">5 2 1 2 3 6   tIndex = 3, t = 4, count = 4, begin = 1</span><br><span class="line">5 2 1 2 3 4   tIndex = 5, t = 6, count = 5, begin = 1</span><br><span class="line">5 6 1 2 3 4   tIndex = 1, t = 2, count = 6, begin = 1</span><br><span class="line">count == nums.size(); 交换完毕</span><br></pre></td></tr></table></figure><p>该方法主要难点是，控制好循环的次数，尤其是 nums.size() 是 k 的倍数的时候。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || nums.size() &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k % nums.size();</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, tIndex = <span class="number">0</span>, t = nums[tIndex], count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            swap(t, nums[(tIndex + k) % length]);</span><br><span class="line">            tIndex = (tIndex + k) % length;</span><br><span class="line">            <span class="keyword">if</span> (tIndex == begin) &#123;</span><br><span class="line">                begin ++;</span><br><span class="line">                tIndex ++;</span><br><span class="line">                t = nums[tIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (count &lt; length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h2><p>一个很巧妙的翻转策略</p><h3 id="解决思路-2"><a href="#解决思路-2" class="headerlink" title="解决思路"></a>解决思路</h3><p>一个很巧妙的交换策略，类似翻转字符的方法，先把前 n - k 个数字翻转一下，再把后 k 个数字翻转一下，最后再把整个数组翻转一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例一为例，采用思路 2 的方法数组 nums 的变化过程如下：</span><br><span class="line">1 2 3 4 5 6 7   原数组nums, k = 3, n = nums.size() = 7</span><br><span class="line">4 3 2 1 5 6 7   先将数组前 n - k 个数字翻转</span><br><span class="line">4 3 2 1 7 6 5   先将数组后 k 个数字翻转</span><br><span class="line">5 6 7 4 3 2 1   最后将整个数组翻转</span><br></pre></td></tr></table></figure><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || nums.size() &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k % nums.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        reverse(nums.begin(), nums.begin() + n - k);</span><br><span class="line">        reverse(nums.begin() + n - k, nums.end());</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路 3"></a>思路 3</h2><p>从倒数第 k 个开始交换</p><h3 id="解决思路-3"><a href="#解决思路-3" class="headerlink" title="解决思路"></a>解决思路</h3><p><strong>核心代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">0</span>; k %= n; n -= k) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">        swap(nums[begin ++], nums[begin + n - k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先将最后k个元素与第k个元素交换。<br>得到结果为k个元素的位置是正确的。<br>我们继续处理剩下的(n - k)元素。<br>一次循环后n = n - k, k = k % n;</p><p>nums[] = [1, 2, 3, 4, 5, 6, 7, 8], k = 2;<br>k   n   |   nums<br>3   8   |   <strong>1,2,3,4,5,6,7,8</strong><br>3   5   |   6,7,8,<strong>4,5,1,2,3</strong><br>1   2   |   6,7,8,1,2,3,<strong>5,4</strong><br>0   1   |   6,7,8,1,2,3,4,<strong>5</strong></p><p>详细过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nums[] = [1, 2, 3, 4, 5, 6, 7, 8], k = 2;</span><br><span class="line">      nums          k   n   i   begin   nums[begin]&lt;==&gt;nums[begin + n - k]</span><br><span class="line">1 2 3 4 5 6 7 8     3   8</span><br><span class="line">                    3   8   0     0     nums[0]&lt;==&gt;nums[5]</span><br><span class="line">6 2 3 4 5 1 7 8     3   8   1     1     nums[1]&lt;==&gt;nums[6]</span><br><span class="line">6 7 3 4 5 1 2 8     3   8   2     2     nums[2]&lt;==&gt;nums[7]</span><br><span class="line">6 7 8 4 5 1 2 3     3   8   3</span><br><span class="line">                    3   5   0     3     nums[3]&lt;==&gt;nums[4]</span><br><span class="line">6 7 8 1 5 4 2 3     3   5   1     4     nums[4]&lt;==&gt;nums[5]</span><br><span class="line">6 7 8 1 2 4 5 3     3   5   2     5     nums[5]&lt;==&gt;nums[6]</span><br><span class="line">6 7 8 1 2 3 5 4     3   5   3</span><br><span class="line">                    1   2   0     6     nums[6]&lt;==&gt;nums[7]</span><br><span class="line">6 7 8 1 2 3 4 5     1   2   1</span><br><span class="line">                    0   1</span><br></pre></td></tr></table></figure><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || nums.size() &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k % nums.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">0</span>; k %= n; n -= k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">                swap(nums[begin ++], nums[begin + n - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-array/descrip
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="简单" scheme="http://www.readmore.ltd/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_6_Z字形变换</title>
    <link href="http://www.readmore.ltd/2018/05/10/LeetCode-6/"/>
    <id>http://www.readmore.ltd/2018/05/10/LeetCode-6/</id>
    <published>2018-05-10T12:54:27.000Z</published>
    <updated>2018-05-21T16:08:53.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/zigzag-conversion/description/" target="_blank" rel="noopener"><code>Z字形变换</code></a> <a href="https://leetcode.com/problems/zigzag-conversion/description/" target="_blank" rel="noopener"><code>ZigZag Conversion</code></a></p><p>将字符串 <code>&quot;PAYPALISHIRING&quot;</code> 以Z字形排列成给定的行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>之后从左往右，逐行读取字符：<code>&quot;PAHNAPLSIIGYIR&quot;</code><br>实现一个将字符串进行指定行数变换的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释:</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 字符串</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>模拟Z字的生成过程，定义一个数组用来存放每一行的字符串，再定义direction一个方向用于扫描字符串时，Z字的方向是向下还是向上，具体信息，看代码，比较容易理解。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str(numRows, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">bool</span> direction = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            str[j] += s[i];</span><br><span class="line">            <span class="keyword">if</span> (j == numRows - <span class="number">1</span>) &#123;</span><br><span class="line">                direction = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                direction = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (direction) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> t : str) &#123;</span><br><span class="line">            result += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zigzag-conversion/de
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="中等" scheme="http://www.readmore.ltd/categories/LeetCode/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_5_最长回文子串</title>
    <link href="http://www.readmore.ltd/2018/05/10/LeetCode-5/"/>
    <id>http://www.readmore.ltd/2018/05/10/LeetCode-5/</id>
    <published>2018-05-10T09:05:29.000Z</published>
    <updated>2018-05-21T16:08:52.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener"><code>最长回文子串</code></a> <a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener"><code>Longest Palindromic Substring</code></a></p><p>给定一个字符串 <strong>s</strong>，找到 <strong>s</strong> 中最长的回文子串。你可以假设 <strong>s</strong> 的最大长度为1000。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 字符串，动态规划</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>解决此题思路主要用了 <a href="https://www.cnblogs.com/love-yh/p/7072161.html" target="_blank" rel="noopener"><code>Manacher&#39;s Algorithm ----马拉车算法</code></a></p><h3 id="马拉车算法："><a href="#马拉车算法：" class="headerlink" title="马拉车算法："></a>马拉车算法：</h3><h4 id="改造字符串-S"><a href="#改造字符串-S" class="headerlink" title="改造字符串 S"></a>改造字符串 S</h4><p>首先用一个非常巧妙的方式，将所有可能的奇数和偶数长度的回文子串都转换成了奇数长度：在每个字符的两边都插入一个特殊的符号。比如： <code>abba --&gt; #a#b#b#a#</code> <code>aba  --&gt; #a#b#a#</code><br>为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如 <code>$#a#b#a#</code> （注意，下面的代码是用 C 语言编写，由于C语言规范还要求字符串末尾有一个’\0’所以正好OK，但其他语言可能会导致越界）。</p><p>以 <code>abaaba</code> 例：<code>T = &quot;$#a#b#a#a#b#a#&quot;</code></p><h4 id="数组-P-的作用"><a href="#数组-P-的作用" class="headerlink" title="数组 P 的作用"></a>数组 P 的作用</h4><p>为了改进回文相互重叠的情况，我们将改造完后的 T[ i ] 处的回文半径存储到数组 P[ ] 中，P[ i ] 为新字符串T的 T[ i ] 处的回文半径（表示以字符 T[ i ] 为中心的最长回文字串的最端右字符到 T[ i ] 的长度），如以 T[ i ] 为中心的最长回文子串的为 T[ l, r ]，那么 P[ i ] = r - i + 1。这样最后遍历数组 P[ ]，取其中最大值即可。若 P[ i ] = 1 表示该回文串就是 T[ i ] 本身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index |  1   2   3   4   5   6   7   8   9   10  11  12  13</span><br><span class="line">  T   |  #   a   #   b   #   a   #   a   #   b   #   a   #  </span><br><span class="line">  P   |  1   2   1   4   1   2   7   2   1   4   1   2   1</span><br></pre></td></tr></table></figure><p><strong>划重点：P[ i ] - 1 正好是原字符串中回文串的总长度</strong></p><p>数组 P 有一性质，P[ i ] - 1 就是该回文子串在原字符串 S 中的长度 ，那就是 P[ i ] - 1 就是该回文子串在原字符串 S 中的长度。<br><strong>证明：</strong>首先在转换得到的字符串 T 中，所有的回文字串的长度都为奇数，那么对于以 T[ i ] 为中心的最长回文字串，其长度就为 2 * P[ i ] - 1,经过观察可知，T 中所有的回文子串，其中分隔符的数量一定比其他字符的数量多 1，也就是有 P[ i ] 个分隔符，剩下 P[ i ] - 1 个字符来自原字符串，所以该回文串在原字符串中的长度就为 P[ i ] - 1。</p><h4 id="计算数组-P"><a href="#计算数组-P" class="headerlink" title="计算数组 P"></a>计算数组 P</h4><p>那么怎么计算P[i]呢？该算法增加两个辅助变量（其实一个就够了，两个更清晰）id 和 mx，其中 id 为已知的 {右边界最大} 的回文子串的<strong>中心</strong>，mx 则为 id + P[ id ]，也就是这个回文子串的右边界。</p><p>然后可以得到一个非常神奇的结论，这个算法的关键点就在这里了：如果 <code>mx &gt; i</code> ，那么 P[ i ] &gt;= MIN(P[2 * id - i], mx - i)。把它写得复杂一点，理解起来会简单很多：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记j = 2 * id - i，也就是说 j 是 i 关于 id 的对称点(j = id - (i - id))</span></span><br><span class="line"><span class="keyword">if</span> (P[j] &gt; mx - i) &#123;</span><br><span class="line">    P[i] = P[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">/* P[j] &gt;= mx - i */</span></span><br><span class="line">    P[i] = mx - i; </span><br><span class="line">    <span class="comment">// P[i] &gt;= mx - i，取最小值，之后再匹配更新（其实后面不会再匹配了，下面会详解）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 <code>mx &lt; i</code> 时 <code>P[i]</code> 再匹配更新。</p><h5 id="计算过程解释"><a href="#计算过程解释" class="headerlink" title="计算过程解释"></a>计算过程解释</h5><ol><li><code>mx &gt; i</code> 时如何计算 P[ i ] 的值？毫无疑问的是数组 P 中点 i 之前点对应的值都已经计算出来了。利用回文串的特性，我们找到点 i 关于 id 的对称点 j ，其值为 j = 2 * id - i 。因为点 j 、i 在以 id 为中心的最大回文串的范围内（[L ,R]）其中 L = id - (mx - id) , R = mx。<ol><li>那么如果 P[ j ] &lt; R - i （同样是 L 和 j 之间的距离），说明，以点 j 为中心的回文串没有超出范围 [L , R]，由回文串的特性可知，从左右两端向 id 遍历，两端对应的字符都是相等的。所以P[ j ] = P[ i ]（这里得先从点 j 转到点 i  的情况），如下图：<br> <img src="https://images2015.cnblogs.com/blog/1168728/201706/1168728-20170624150751538-286806776.png" alt=""></li><li>如果P[ j ] &gt;= R - i （即 j 为中心的回文串的最左端超过 L），如下图所示。即，以点 j为中心的最大回文串的范围已经超出了范围[L ,R] ，这种情况，等式P[ j ] = P[ i ]还成立吗？显然是不成立的！因，以点 j 为中心的回文串的最左端超过 L，那么在[L, j]之间的字符肯定能在(j, id]找到相等的，由回文串的特性可知，P[ i ] 等于 R- i，至于是否大于 R - i（图中红色的部分），肯定不会，如果大于 R - i 那么以 id 为中心的回文串就大于 mx，若图中的红色部分是 i 的回文，则肯定和 j 那边对应，增长 id 回文长度，所以从 R + 1 开始匹配，R + 1 就会失配，为了代码书写简单，就让他继续匹配，而不用引入新的分支进行判断。<br> <img src="https://images2015.cnblogs.com/blog/1168728/201706/1168728-20170624164713366-717289734.png" alt=""></li></ol></li><li><code>i &gt; mx</code> 时，如下图。这种情况，没法利用到回文串的特性，只能老老实实的一步步去匹配。<br> <img src="https://images2015.cnblogs.com/blog/1168728/201706/1168728-20170624171657601-779083481.png" alt=""></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">"$"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">            t = t + <span class="string">"#"</span> + s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        t = t + <span class="string">"#\0"</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(t.length() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, reId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; t[i] != <span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">            p[i] = mx &gt; i ? min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) &#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; mx) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[reId] &lt; p[i]) &#123;</span><br><span class="line">                reId = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr((reId - p[reId]) / <span class="number">2</span>, p[reId] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="中等" scheme="http://www.readmore.ltd/categories/LeetCode/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_4_两个排序数组的中位数</title>
    <link href="http://www.readmore.ltd/2018/05/09/LeetCode-4/"/>
    <id>http://www.readmore.ltd/2018/05/09/LeetCode-4/</id>
    <published>2018-05-09T13:05:04.000Z</published>
    <updated>2018-05-25T06:54:24.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener"><code>两个排序数组的中位数</code></a> <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener"><code>Median of Two Sorted Arrays</code></a></p><p>给定两个大小为 m 和 n 的有序数组 <strong>nums1</strong> 和 <strong>nums2</strong> 。<br>请找出这两个有序数组的中位数。要求算法的时间复杂度为 $O(\log (m+n))$ 。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">中位数是 2.0</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 数组，二分查找，分治算法</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>题目给定两个有序的数组，找出中位数并不困难，最简单的一个循环就行，时间复杂度 $O(m+n)$ 。但是题目要求时间复杂度为 $O(\log (m+n))$ 就是一个大问题，具体思路采用二分查找，如下：</p><p>其中k 表示要求的中位数的位置，初始化 $k = (m + n + 1) / 2$ 和 $k = (m + n + 2) / 2$，即 $m + n$ 是偶数时为中间两个， $m + n$ 是奇数时为中位数的后面一个。</p><p>首先将 A 划分为左右两部分，其中 $i = k / 2$ ，$length(left_A) = i，length(right_A) = k - i$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      left_A             |        right_A</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br></pre></td></tr></table></figure><p>然后将 B 划分为左右两部分，其中 $j = k / 2$ ，$length(left_A) = j，length(right_A) = k - j$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      left_B             |        right_B</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure><p>则，A、B 数组可分为左右两部分，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           left          |          right</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure><p><em><strong>划重点来了</strong></em></p><p>如果，$A[i-1] &gt; B[j-1]$，则说明，中位数一定在 $left_A、right_A、right_B$中，这样就排除了$left_B$，想想这是为什么？<br>因为有$A[i-1] &gt; B[j-1]$ 不妨设 $A[0] &gt; B[p]，p=0,1,2,\ldots,j-1$ 则中位数一定不在$left_B$中，所以缩小查找范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           left          |          right</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line">                         |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure><p>如果，$A[i-1] &lt; B[j-1]$，则说明，中位数一定在 $right_A、left_B、right_B$中，这样就排除了$left_A$，想想这是为什么？理由同上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           left          |          right</span><br><span class="line">                         |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure><p>接下来，将缩小范围的新数组 A 或者 B 按同样的划分，同样的缩小范围，就可得到最后结果。</p><p>由上可得，方法为二分查找，定义递归函数，确定<strong>递归函数的出口</strong>为：</p><ul><li>当某个数组的数都被取完了，那么直接返回另一个数组剩下的的第 k 个元素即可。</li><li>当 k = 1 时，也就是只需再找一个数即可，也就是取两者当前较小的那个即可。</li></ul><p>如何确定奇数个数取中位数，偶数个数取中间两个数的平均数，我想，利用整数除法的规则，很容易就得到 中位数为 <code>(m + n + 1) &gt;&gt; 1</code> 这个数与 <code>(m + n + 2) &gt;&gt; 1</code> 取平均值即可，当个数为奇数时，两个数就是中间一个数。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> l = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = (m + n + <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>* ln = m &gt; <span class="number">0</span> ? &amp;nums1[<span class="number">0</span>] : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span>* rn = n &gt; <span class="number">0</span> ? &amp;nums2[<span class="number">0</span>] : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ( getKth(ln, m, rn, n, l) + getKth(ln, m, rn, n, r) ) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>* ln, <span class="keyword">int</span> m, <span class="keyword">int</span>* rn, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(rn, n, ln, m, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rn[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(ln[<span class="number">0</span>], rn[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = min(m, k / <span class="number">2</span>), j = min(n, k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (ln[i - <span class="number">1</span>] &gt; rn [j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(ln, m, rn + j, n - j, k - j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(ln + i, m - i, rn, n, k - i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="困难" scheme="http://www.readmore.ltd/categories/LeetCode/%E5%9B%B0%E9%9A%BE/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_3_无重复字符的最长子串</title>
    <link href="http://www.readmore.ltd/2018/05/09/LeetCode-3/"/>
    <id>http://www.readmore.ltd/2018/05/09/LeetCode-3/</id>
    <published>2018-05-09T10:44:26.000Z</published>
    <updated>2018-05-21T16:08:56.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener"><code>无重复字符的最长子串</code></a> <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener"><code>Longest Substring Without Repeating Characters</code></a></p><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：abcabcbb</span><br><span class="line">输出：3</span><br><span class="line">原因：没有重复字符的最长子串是 &quot;abc&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bbbbb</span><br><span class="line">输出：1</span><br><span class="line">原因：没有重复字符的最长子串是 &quot;b&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pwwkew</span><br><span class="line">输出：3</span><br><span class="line">原因：没有重复字符的最长子串是 &quot;wke&quot;。请注意答案必须是一个子串，`&quot;pwke&quot;` 是 **子序列**  而不是子串。</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 哈希表, 双指针, 字符串</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ol><li>因为一个字符的 ASCII 的取值范围为 0–255 ，则定义一个 256 长的数组，其值表示当前循环指针 i 指向的字符的 ASCII 值为下标的字符最后一次出现在输入字符串的位置（从 0 开始）,初始化为 -1 表示没有出现过；</li><li>j 指向当前的循环指针 i 前没有重复字符子串的首字符，如字符串 abcabcbb ，i = 3 时，j = 1，i = 6 时，j = 5。</li><li>当当前i指向的字符在前面出现过时，若出现过的位置在j之前j不变，若在j之后则j指向出现过位置的下一个。</li><li>maxLen存储最长子串的长的，若现在的子串长度i - j + 1更长时更新maxLen.</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; charIndex(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            j = max(j, charIndex[s[i]] + <span class="number">1</span>);</span><br><span class="line">            charIndex[s[i]] = i;</span><br><span class="line">            maxLen = max(maxLen, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-wi
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="中等" scheme="http://www.readmore.ltd/categories/LeetCode/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_2_两数相加</title>
    <link href="http://www.readmore.ltd/2018/05/09/LeetCode-2/"/>
    <id>http://www.readmore.ltd/2018/05/09/LeetCode-2/</id>
    <published>2018-05-09T08:19:08.000Z</published>
    <updated>2018-05-21T16:09:03.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/description/" target="_blank" rel="noopener"><code>两数相加</code></a> <a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener"><code>Add Two Numbers</code></a></p><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 链表, 数学</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>一个大数相加问题，注意的是链表存储的两个非负整数，位数是按照<strong>逆序</strong>方式存储的；比如<code>342</code>这个数，存储为<code>2 -&gt; 4 -&gt; 3</code>。</p><p><strong>注意：</strong></p><ol><li>输入的两个链表可能不一样长，需要对较长链表<strong>剩余的高位</strong>和<strong>进位</strong>计算的值；</li><li>产生进位时加到下一位，即下一个结点；</li><li>循环退出后可能最后一次计算还有近位，要考虑全面。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  2 -&gt; 3 -&gt; 5 -&gt; 9 -&gt; 9</span><br><span class="line">+ 3 -&gt; 7 -&gt; 9</span><br><span class="line">----------------------------</span><br><span class="line">= 5 -&gt; 0 -&gt; 5 -&gt; 0 -&gt; 0 -&gt; 1</span><br></pre></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = l1;</span><br><span class="line">        ListNode* q = l2;</span><br><span class="line">        ListNode* t = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* result = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span> || q != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            t-&gt;next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                sum += p-&gt;val;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                sum += q-&gt;val;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            t-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum / <span class="number">10</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            t-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/desc
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="中等" scheme="http://www.readmore.ltd/categories/LeetCode/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_1_两数之和(Two Sum)</title>
    <link href="http://www.readmore.ltd/2018/05/08/LeetCode-1/"/>
    <id>http://www.readmore.ltd/2018/05/08/LeetCode-1/</id>
    <published>2018-05-08T11:44:47.000Z</published>
    <updated>2018-05-21T16:08:57.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/two-sum/description/" target="_blank" rel="noopener"><code>两数之和</code></a> <a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener"><code>Two Sum</code></a></p><p>给定一个整数数组和一个目标值，找出数组中和为目标值的<strong>两个</strong>数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 数组, 哈希表</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>利用 <strong>unordered_map</strong> 作为存储，键为当前元素值，索引为在 <code>numbers</code>中的下标值，比如 <code>i = 0</code> 时，此时首先要判断 <code>target - numbers[0] = 7</code> 是否在 <strong>map</strong> 中，如果不存在，那么插入键值对 <code>key = numbers[0] = 2, value = i = 0</code>，之后当 <code>i = 1</code> 时，此时判断 <code>target - numbers[1] = 2</code> 已存在于 <strong>map</strong> 中，那么取出该 <code>value = 0</code> 作为第一个返回值，当前 <code>i</code> 作为第二个返回值。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> numberToFind = target - numbers[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.find(numberToFind) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                result.push_back(<span class="built_in">map</span>[numberToFind]);</span><br><span class="line">                result.push_back(i);            </span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[numbers[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/description/
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="简单" scheme="http://www.readmore.ltd/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Offer_53题</title>
    <link href="http://www.readmore.ltd/2018/05/07/Offer-53/"/>
    <id>http://www.readmore.ltd/2018/05/07/Offer-53/</id>
    <published>2018-05-07T07:53:08.000Z</published>
    <updated>2018-05-07T08:31:12.596Z</updated>
    
    <content type="html"><![CDATA[<h4 id="统计一个数字在排序数组中出现的次数"><a href="#统计一个数字在排序数组中出现的次数" class="headerlink" title="统计一个数字在排序数组中出现的次数"></a>统计一个数字在排序数组中出现的次数</h4><blockquote><p>求在升序排序数组中，指定数字K第一次出现的下标和最后一次出现的下标<br>基本思想是二分查找<br>要求是输入的数组为升序</p></blockquote><p><strong>题目：统计一个数字在排序数组中出现的次数。例如输入排序数组{1,2,3,3,3,3,4,5}和数字3，由于3在这个数组中出现了4次，因此输出4。</strong></p><p><strong>二分查找</strong></p><ul><li>假设我们需要找的数字是k，那么就需要找到数组中的第一个k和最后一个k出现的位置。</li><li>如何通过二分查找得到第一个k的位置呢？<ul><li>取数组中间的数字与k作比较，</li><li>如果该数字比k大，那么k只能出现在前半部分，那么下一轮只能在前半部分找；</li><li>如果该数字比k小，那么k只能出现在后半部分，那么下一轮只能在后半部分找；</li><li>如果该数字等于k，需要判断这是不是第一个k，如果该数字的前一个数字不是k，那么该数字就是第一个k，否则需要在前半部分继续寻找第一个k；</li><li>寻找最后一个k的方法与寻找第一个k的方法一样。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在排序数组中，指定数字K第一次出现的下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param data 升序数组</span></span><br><span class="line"><span class="comment"> * @param n 数组长度</span></span><br><span class="line"><span class="comment"> * @param k 指定数字</span></span><br><span class="line"><span class="comment"> * @param start 数组的某段从start开始</span></span><br><span class="line"><span class="comment"> * @param end 数组的某段在end结束</span></span><br><span class="line"><span class="comment"> * @return 指定数字K第一次出现的下标，数组中若没有K，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在排序数组中，指定数字K最后一次出现的下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param data 升序数组</span></span><br><span class="line"><span class="comment"> * @param n 数组长度</span></span><br><span class="line"><span class="comment"> * @param k 指定数字</span></span><br><span class="line"><span class="comment"> * @param start 数组的某段从start开始</span></span><br><span class="line"><span class="comment"> * @param end 数组的某段在end结束</span></span><br><span class="line"><span class="comment"> * @return 指定数字K最后一次出现的下标，数组中若没有K，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算K出现的次数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param data 升序数组</span></span><br><span class="line"><span class="comment"> * @param n 数组长度</span></span><br><span class="line"><span class="comment"> * @param k 指定数字</span></span><br><span class="line"><span class="comment"> * @return 次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumberK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> data[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; getNumberK(data, n, k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middleIndex = (start + end) &gt;&gt; <span class="number">1</span>;<span class="comment">//移位运算比算术运算快。</span></span><br><span class="line">    <span class="keyword">int</span> middleData = data[middleIndex];</span><br><span class="line">    <span class="keyword">if</span> (middleData == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((middleIndex &gt; <span class="number">0</span> &amp;&amp; data[middleIndex - <span class="number">1</span>] != k) || middleIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> middleIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = middleIndex - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middleData &gt; k) &#123;</span><br><span class="line">        end = middleIndex - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = middleIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getFirstK(data, n, k, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middleIndex = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> middleData = data[middleIndex];</span><br><span class="line">    <span class="keyword">if</span> (middleData == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((middleIndex &lt; n - <span class="number">1</span> &amp;&amp; data[middleIndex + <span class="number">1</span>] != k) || middleIndex == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> middleIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = middleIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middleData &gt; k) &#123;</span><br><span class="line">        end = middleIndex - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = middleIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getLastK(data, n, k, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumberK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numberK = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">nullptr</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> firstIndexK = getFirstK(data, n, k, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> lastIndexK = getLastK(data, n, k, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (firstIndexK &gt; <span class="number">-1</span> &amp;&amp; lastIndexK &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            numberK = lastIndexK - firstIndexK + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numberK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;统计一个数字在排序数组中出现的次数&quot;&gt;&lt;a href=&quot;#统计一个数字在排序数组中出现的次数&quot; class=&quot;headerlink&quot; title=&quot;统计一个数字在排序数组中出现的次数&quot;&gt;&lt;/a&gt;统计一个数字在排序数组中出现的次数&lt;/h4&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="剑指Offer" scheme="http://www.readmore.ltd/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>观察者(Observer)模式</title>
    <link href="http://www.readmore.ltd/2018/05/02/%E8%A7%82%E5%AF%9F%E8%80%85-Observer-%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.readmore.ltd/2018/05/02/观察者-Observer-模式/</id>
    <published>2018-05-02T12:17:39.000Z</published>
    <updated>2018-05-21T16:08:54.220Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>观察者模式 — 让你的对象知悉现况<br>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p></blockquote><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p><strong>基本需求：利用WeatherData对象获取数据、并更新三个布告板：目前状况、气象统计和天气预报</strong></p><ul><li>客户有一个WeatherData对象，负责追踪温度、湿度和气压等数据。现在客户给我们提了个需求，让我们利用WeatherData对象取得数据，并更新三个布告板：目前状况、气象统计和天气预报。</li><li>WeatherData对象提供了4个接口：<ul><li><code>getTemperature()</code>：获取温度</li><li><code>getHumidity()</code>：获取湿度</li><li><code>getPressure()</code>：获取气压</li><li><code>measurementsChanged()</code>：一旦气象测量更新，此方法会被调用</li></ul></li><li>我们的工作是实现measurementsChanged()，好让它更新目前状况、气象统计、天气预报的显示布告板。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;观察者模式 — 让你的对象知悉现况&lt;br&gt;观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;提出问题&quot;&gt;&lt;a href=&quot;#提出问题&quot; 
      
    
    </summary>
    
      <category term="source" scheme="http://www.readmore.ltd/categories/source/"/>
    
    
      <category term="设计模式" scheme="http://www.readmore.ltd/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
