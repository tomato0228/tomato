<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tomato Blog</title>
  
  <subtitle>The days of Tomato and Readmore</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.readmore.ltd/"/>
  <updated>2018-05-10T14:09:44.537Z</updated>
  <id>http://www.readmore.ltd/</id>
  
  <author>
    <name>Tomato</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode_6_Z字形变换</title>
    <link href="http://www.readmore.ltd/2018/05/10/LeetCode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://www.readmore.ltd/2018/05/10/LeetCode-6-Z字形变换/</id>
    <published>2018-05-10T12:54:27.000Z</published>
    <updated>2018-05-10T14:09:44.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/zigzag-conversion/description/" target="_blank" rel="noopener"><code>Z字形变换</code></a> <a href="https://leetcode.com/problems/zigzag-conversion/description/" target="_blank" rel="noopener"><code>ZigZag Conversion</code></a></p><p>将字符串 <code>&quot;PAYPALISHIRING&quot;</code> 以Z字形排列成给定的行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>之后从左往右，逐行读取字符：<code>&quot;PAHNAPLSIIGYIR&quot;</code><br>实现一个将字符串进行指定行数变换的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释:</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 字符串</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>模拟Z字的生成过程，定义一个数组用来存放每一行的字符串，再定义direction一个方向用于扫描字符串时，Z字的方向是向下还是向上，具体信息，看代码，比较容易理解。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str(numRows, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">bool</span> direction = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            str[j] += s[i];</span><br><span class="line">            <span class="keyword">if</span> (j == numRows - <span class="number">1</span>) &#123;</span><br><span class="line">                direction = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                direction = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (direction) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> t : str) &#123;</span><br><span class="line">            result += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zigzag-conversion/de
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="中等" scheme="http://www.readmore.ltd/categories/LeetCode/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode-中等" scheme="http://www.readmore.ltd/tags/LeetCode-%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_5_最长回文子串</title>
    <link href="http://www.readmore.ltd/2018/05/10/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://www.readmore.ltd/2018/05/10/LeetCode-5-最长回文子串/</id>
    <published>2018-05-10T09:05:29.000Z</published>
    <updated>2018-05-10T12:23:58.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener"><code>最长回文子串</code></a> <a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener"><code>Longest Palindromic Substring</code></a></p><p>给定一个字符串 <strong>s</strong>，找到 <strong>s</strong> 中最长的回文子串。你可以假设 <strong>s</strong> 的最大长度为1000。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 字符串，动态规划</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>解决此题思路主要用了 <a href="https://www.cnblogs.com/love-yh/p/7072161.html" target="_blank" rel="noopener"><code>Manacher&#39;s Algorithm ----马拉车算法</code></a><a href="https://www.felix021.com/blog/read.php?2040" target="_blank" rel="noopener">https://www.felix021.com/blog/read.php?2040</a></p><h3 id="马拉车算法："><a href="#马拉车算法：" class="headerlink" title="马拉车算法："></a>马拉车算法：</h3><h4 id="改造字符串-S"><a href="#改造字符串-S" class="headerlink" title="改造字符串 S"></a>改造字符串 S</h4><p>首先用一个非常巧妙的方式，将所有可能的奇数和偶数长度的回文子串都转换成了奇数长度：在每个字符的两边都插入一个特殊的符号。比如： <code>abba --&gt; #a#b#b#a#</code> <code>aba  --&gt; #a#b#a#</code><br>为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如 <code>$#a#b#a#</code> （注意，下面的代码是用 C 语言编写，由于C语言规范还要求字符串末尾有一个’\0’所以正好OK，但其他语言可能会导致越界）。</p><p>以 <code>abaaba</code> 例：<code>T = &quot;$#a#b#a#a#b#a#&quot;</code></p><h4 id="数组-P-的作用"><a href="#数组-P-的作用" class="headerlink" title="数组 P 的作用"></a>数组 P 的作用</h4><p>为了改进回文相互重叠的情况，我们将改造完后的 T[ i ] 处的回文半径存储到数组 P[ ] 中，P[ i ] 为新字符串T的 T[ i ] 处的回文半径（表示以字符 T[ i ] 为中心的最长回文字串的最端右字符到 T[ i ] 的长度），如以 T[ i ] 为中心的最长回文子串的为 T[ l, r ]，那么 P[ i ] = r - i + 1。这样最后遍历数组 P[ ]，取其中最大值即可。若 P[ i ] = 1 表示该回文串就是 T[ i ] 本身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index |  1   2   3   4   5   6   7   8   9   10  11  12  13</span><br><span class="line">  T   |  #   a   #   b   #   a   #   a   #   b   #   a   #  </span><br><span class="line">  P   |  1   2   1   4   1   2   7   2   1   4   1   2   1</span><br></pre></td></tr></table></figure><p><strong>划重点：P[ i ] - 1 正好是原字符串中回文串的总长度</strong></p><p>数组 P 有一性质，P[ i ] - 1 就是该回文子串在原字符串 S 中的长度 ，那就是 P[ i ] - 1 就是该回文子串在原字符串 S 中的长度。<br><strong>证明：</strong>首先在转换得到的字符串 T 中，所有的回文字串的长度都为奇数，那么对于以 T[ i ] 为中心的最长回文字串，其长度就为 2 * P[ i ] - 1,经过观察可知，T 中所有的回文子串，其中分隔符的数量一定比其他字符的数量多 1，也就是有 P[ i ] 个分隔符，剩下 P[ i ] - 1 个字符来自原字符串，所以该回文串在原字符串中的长度就为 P[ i ] - 1。</p><h4 id="计算数组-P"><a href="#计算数组-P" class="headerlink" title="计算数组 P"></a>计算数组 P</h4><p>那么怎么计算P[i]呢？该算法增加两个辅助变量（其实一个就够了，两个更清晰）id 和 mx，其中 id 为已知的 {右边界最大} 的回文子串的<strong>中心</strong>，mx 则为 id + P[ id ]，也就是这个回文子串的右边界。</p><p>然后可以得到一个非常神奇的结论，这个算法的关键点就在这里了：如果 <code>mx &gt; i</code> ，那么 P[ i ] &gt;= MIN(P[2 * id - i], mx - i)。把它写得复杂一点，理解起来会简单很多：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记j = 2 * id - i，也就是说 j 是 i 关于 id 的对称点(j = id - (i - id))</span></span><br><span class="line"><span class="keyword">if</span> (P[j] &gt; mx - i) &#123;</span><br><span class="line">    P[i] = P[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">/* P[j] &gt;= mx - i */</span></span><br><span class="line">    P[i] = mx - i; </span><br><span class="line">    <span class="comment">// P[i] &gt;= mx - i，取最小值，之后再匹配更新（其实后面不会再匹配了，下面会详解）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 <code>mx &lt; i</code> 时 <code>P[i]</code> 再匹配更新。</p><h5 id="计算过程解释"><a href="#计算过程解释" class="headerlink" title="计算过程解释"></a>计算过程解释</h5><ol><li><code>mx &gt; i</code> 时如何计算 P[ i ] 的值？毫无疑问的是数组 P 中点 i 之前点对应的值都已经计算出来了。利用回文串的特性，我们找到点 i 关于 id 的对称点 j ，其值为 j = 2 * id - i 。因为点 j 、i 在以 id 为中心的最大回文串的范围内（[L ,R]）其中 L = id - (mx - id) , R = mx。<ol><li>那么如果 P[ j ] &lt; R - i （同样是 L 和 j 之间的距离），说明，以点 j 为中心的回文串没有超出范围 [L , R]，由回文串的特性可知，从左右两端向 id 遍历，两端对应的字符都是相等的。所以P[ j ] = P[ i ]（这里得先从点 j 转到点 i  的情况），如下图：<br> <img src="https://images2015.cnblogs.com/blog/1168728/201706/1168728-20170624150751538-286806776.png" alt=""></li><li>如果P[ j ] &gt;= R - i （即 j 为中心的回文串的最左端超过 L），如下图所示。即，以点 j为中心的最大回文串的范围已经超出了范围[L ,R] ，这种情况，等式P[ j ] = P[ i ]还成立吗？显然是不成立的！因，以点 j 为中心的回文串的最左端超过 L，那么在[L, j]之间的字符肯定能在(j, id]找到相等的，由回文串的特性可知，P[ i ] 等于 R- i，至于是否大于 R - i（图中红色的部分），肯定不会，如果大于 R - i 那么以 id 为中心的回文串就大于 mx，若图中的红色部分是 i 的回文，则肯定和 j 那边对应，增长 id 回文长度，所以从 R + 1 开始匹配，R + 1 就会失配，为了代码书写简单，就让他继续匹配，而不用引入新的分支进行判断。<br> <img src="https://images2015.cnblogs.com/blog/1168728/201706/1168728-20170624164713366-717289734.png" alt=""></li></ol></li><li><code>i &gt; mx</code> 时，如下图。这种情况，没法利用到回文串的特性，只能老老实实的一步步去匹配。<br> <img src="https://images2015.cnblogs.com/blog/1168728/201706/1168728-20170624171657601-779083481.png" alt=""></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">"$"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">            t = t + <span class="string">"#"</span> + s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        t = t + <span class="string">"#\0"</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(t.length() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, reId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; t[i] != <span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">            p[i] = mx &gt; i ? min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) &#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; mx) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[reId] &lt; p[i]) &#123;</span><br><span class="line">                reId = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr((reId - p[reId]) / <span class="number">2</span>, p[reId] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="中等" scheme="http://www.readmore.ltd/categories/LeetCode/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode-中等" scheme="http://www.readmore.ltd/tags/LeetCode-%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_4_两个排序数组的中位数</title>
    <link href="http://www.readmore.ltd/2018/05/09/LeetCode-4-%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://www.readmore.ltd/2018/05/09/LeetCode-4-两个排序数组的中位数/</id>
    <published>2018-05-09T13:05:04.000Z</published>
    <updated>2018-05-10T11:08:28.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener"><code>两个排序数组的中位数</code></a> <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener"><code>Median of Two Sorted Arrays</code></a></p><p>给定两个大小为 m 和 n 的有序数组 <strong>nums1</strong> 和 <strong>nums2</strong> 。<br>请找出这两个有序数组的中位数。要求算法的时间复杂度为 $O(\log (m+n))$ 。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">中位数是 2.0</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 数组，二分查找，分治算法</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>题目给定两个有序的数组，找出中位数并不困难，最简单的一个循环就行，时间复杂度 $O(m+n)$ 。但是题目要求时间复杂度为 $O(\log (m+n))$ 就是一个大问题，具体思路采用二分查找，如下：</p><p>首先将 A 划分为左右两部分，其中 $i = m / 2$ ，$length(left_A) = i，length(right_A) = m - i$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      left_A             |        right_A</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br></pre></td></tr></table></figure><p>然后将 B 划分为左右两部分，其中 $j = n / 2$ ，$length(left_A) = j，length(right_A) = n - j$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      left_B             |        right_B</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure><p>则，A、B 数组可分为左右两部分，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           left          |          right</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure><p><em><strong>划重点来了</strong></em></p><p>如果，$A[i-1] &gt; B[j-1]$，则说明，中位数一定在 $left_A、right_A、right_B$中，这样就排除了$left_B$，想想这是为什么？<br>因为有$A[i-1] &gt; B[j-1]$ 不妨设 $A[0] &gt; B[jj]，jj=0,1,2,\ldots,j-1$ 则中位数一定不在$left_B$中，所以缩小查找范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           left          |          right</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line">                         |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure><p>如果，$A[i-1] &lt; B[j-1]$，则说明，中位数一定在 $right_A、left_B、right_B$中，这样就排除了$left_A$，想想这是为什么？理由同上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           left          |          right</span><br><span class="line">                         |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure><p>接下来，将缩小范围的新数组 A 或者 B 按同样的划分，同样的缩小范围，就可得到最后结果。</p><p>由上可得，方法为二分查找，定义递归函数，确定<strong>递归函数的出口</strong>为：</p><ul><li>当某个数组的数都被取完了，那么直接返回另一个数组剩下的的第 k 个元素即可。</li><li>当 k = 1 时，也就是只需再找一个数即可，也就是取两者当前较小的那个即可。</li></ul><p>如何确定奇数个数取中位数，偶数个数取中间两个数的平均数，我想，利用整数除法的规则，很容易就得到 中位数为 <code>(m + n + 1) &gt;&gt; 1</code> 这个数与 <code>(m + n + 2) &gt;&gt; 1</code> 取平均值即可，当个数为奇数时，两个数就是中间一个数。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> l = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = (m + n + <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>* ln = m &gt; <span class="number">0</span> ? &amp;nums1[<span class="number">0</span>] : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span>* rn = n &gt; <span class="number">0</span> ? &amp;nums2[<span class="number">0</span>] : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ( getKth(ln, m, rn, n, l) + getKth(ln, m, rn, n, r) ) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>* ln, <span class="keyword">int</span> m, <span class="keyword">int</span>* rn, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(rn, n, ln, m, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rn[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(ln[<span class="number">0</span>], rn[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = min(m, k / <span class="number">2</span>), j = min(n, k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (ln[i - <span class="number">1</span>] &gt; rn [j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(ln, m, rn + j, n - j, k - j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(ln + i, m - i, rn, n, k - i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="困难" scheme="http://www.readmore.ltd/categories/LeetCode/%E5%9B%B0%E9%9A%BE/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode-困难" scheme="http://www.readmore.ltd/tags/LeetCode-%E5%9B%B0%E9%9A%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_3_无重复字符的最长子串</title>
    <link href="http://www.readmore.ltd/2018/05/09/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://www.readmore.ltd/2018/05/09/LeetCode-3-无重复字符的最长子串/</id>
    <published>2018-05-09T10:44:26.000Z</published>
    <updated>2018-05-10T11:08:23.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener"><code>无重复字符的最长子串</code></a> <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener"><code>Longest Substring Without Repeating Characters</code></a></p><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：abcabcbb</span><br><span class="line">输出：3</span><br><span class="line">原因：没有重复字符的最长子串是 &quot;abc&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bbbbb</span><br><span class="line">输出：1</span><br><span class="line">原因：没有重复字符的最长子串是 &quot;b&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pwwkew</span><br><span class="line">输出：3</span><br><span class="line">原因：没有重复字符的最长子串是 &quot;wke&quot;。请注意答案必须是一个子串，`&quot;pwke&quot;` 是 **子序列**  而不是子串。</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 哈希表, 双指针, 字符串</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ol><li>因为一个字符的 ASCII 的取值范围为 0–255 ，则定义一个 256 长的数组，其值表示当前循环指针 i 指向的字符的 ASCII 值为下标的字符最后一次出现在输入字符串的位置（从 0 开始）,初始化为 -1 表示没有出现过；</li><li>j 指向当前的循环指针 i 前没有重复字符子串的首字符，如字符串 abcabcbb ，i = 3 时，j = 1，i = 6 时，j = 5。</li><li>当当前i指向的字符在前面出现过时，若出现过的位置在j之前j不变，若在j之后则j指向出现过位置的下一个。</li><li>maxLen存储最长子串的长的，若现在的子串长度i - j + 1更长时更新maxLen.</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; charIndex(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            j = max(j, charIndex[s[i]] + <span class="number">1</span>);</span><br><span class="line">            charIndex[s[i]] = i;</span><br><span class="line">            maxLen = max(maxLen, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-wi
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="中等" scheme="http://www.readmore.ltd/categories/LeetCode/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode-中等" scheme="http://www.readmore.ltd/tags/LeetCode-%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_2_两数相加</title>
    <link href="http://www.readmore.ltd/2018/05/09/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://www.readmore.ltd/2018/05/09/LeetCode-2-两数相加/</id>
    <published>2018-05-09T08:19:08.000Z</published>
    <updated>2018-05-10T11:08:22.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/description/" target="_blank" rel="noopener"><code>两数相加</code></a> <a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener"><code>Add Two Numbers</code></a></p><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 链表, 数学</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>一个大数相加问题，注意的是链表存储的两个非负整数，位数是按照<strong>逆序</strong>方式存储的；比如<code>342</code>这个数，存储为<code>2 -&gt; 4 -&gt; 3</code>。</p><p><strong>注意：</strong></p><ol><li>输入的两个链表可能不一样长，需要对较长链表<strong>剩余的高位</strong>和<strong>进位</strong>计算的值；</li><li>产生进位时加到下一位，即下一个结点；</li><li>循环退出后可能最后一次计算还有近位，要考虑全面。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  2 -&gt; 3 -&gt; 5 -&gt; 9 -&gt; 9</span><br><span class="line">+ 3 -&gt; 7 -&gt; 9</span><br><span class="line">----------------------------</span><br><span class="line">= 5 -&gt; 0 -&gt; 5 -&gt; 0 -&gt; 0 -&gt; 1</span><br></pre></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = l1;</span><br><span class="line">        ListNode* q = l2;</span><br><span class="line">        ListNode* t = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* result = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span> || q != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            t-&gt;next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                sum += p-&gt;val;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                sum += q-&gt;val;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            t-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum / <span class="number">10</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            t-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/desc
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="中等" scheme="http://www.readmore.ltd/categories/LeetCode/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode-中等" scheme="http://www.readmore.ltd/tags/LeetCode-%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_1_两数之和(Two Sum)</title>
    <link href="http://www.readmore.ltd/2018/05/08/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://www.readmore.ltd/2018/05/08/LeetCode-1-两数之和/</id>
    <published>2018-05-08T11:44:47.000Z</published>
    <updated>2018-05-10T11:08:20.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/two-sum/description/" target="_blank" rel="noopener"><code>两数之和</code></a> <a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener"><code>Two Sum</code></a></p><p>给定一个整数数组和一个目标值，找出数组中和为目标值的<strong>两个</strong>数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p><strong>Tags</strong>: 数组, 哈希表</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>利用 <strong>unordered_map</strong> 作为存储，键为当前元素值，索引为在 <code>numbers</code>中的下标值，比如 <code>i = 0</code> 时，此时首先要判断 <code>target - numbers[0] = 7</code> 是否在 <strong>map</strong> 中，如果不存在，那么插入键值对 <code>key = numbers[0] = 2, value = i = 0</code>，之后当 <code>i = 1</code> 时，此时判断 <code>target - numbers[1] = 2</code> 已存在于 <strong>map</strong> 中，那么取出该 <code>value = 0</code> 作为第一个返回值，当前 <code>i</code> 作为第二个返回值。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> numberToFind = target - numbers[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.find(numberToFind) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                result.push_back(<span class="built_in">map</span>[numberToFind]);</span><br><span class="line">                result.push_back(i);            </span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[numbers[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/description/
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.readmore.ltd/categories/LeetCode/"/>
    
      <category term="简单" scheme="http://www.readmore.ltd/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode-简单" scheme="http://www.readmore.ltd/tags/LeetCode-%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>Offer_53题</title>
    <link href="http://www.readmore.ltd/2018/05/07/Offer-53%E9%A2%98/"/>
    <id>http://www.readmore.ltd/2018/05/07/Offer-53题/</id>
    <published>2018-05-07T07:53:08.000Z</published>
    <updated>2018-05-07T08:31:12.596Z</updated>
    
    <content type="html"><![CDATA[<h4 id="统计一个数字在排序数组中出现的次数"><a href="#统计一个数字在排序数组中出现的次数" class="headerlink" title="统计一个数字在排序数组中出现的次数"></a>统计一个数字在排序数组中出现的次数</h4><blockquote><p>求在升序排序数组中，指定数字K第一次出现的下标和最后一次出现的下标<br>基本思想是二分查找<br>要求是输入的数组为升序</p></blockquote><p><strong>题目：统计一个数字在排序数组中出现的次数。例如输入排序数组{1,2,3,3,3,3,4,5}和数字3，由于3在这个数组中出现了4次，因此输出4。</strong></p><p><strong>二分查找</strong></p><ul><li>假设我们需要找的数字是k，那么就需要找到数组中的第一个k和最后一个k出现的位置。</li><li>如何通过二分查找得到第一个k的位置呢？<ul><li>取数组中间的数字与k作比较，</li><li>如果该数字比k大，那么k只能出现在前半部分，那么下一轮只能在前半部分找；</li><li>如果该数字比k小，那么k只能出现在后半部分，那么下一轮只能在后半部分找；</li><li>如果该数字等于k，需要判断这是不是第一个k，如果该数字的前一个数字不是k，那么该数字就是第一个k，否则需要在前半部分继续寻找第一个k；</li><li>寻找最后一个k的方法与寻找第一个k的方法一样。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在排序数组中，指定数字K第一次出现的下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param data 升序数组</span></span><br><span class="line"><span class="comment"> * @param n 数组长度</span></span><br><span class="line"><span class="comment"> * @param k 指定数字</span></span><br><span class="line"><span class="comment"> * @param start 数组的某段从start开始</span></span><br><span class="line"><span class="comment"> * @param end 数组的某段在end结束</span></span><br><span class="line"><span class="comment"> * @return 指定数字K第一次出现的下标，数组中若没有K，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在排序数组中，指定数字K最后一次出现的下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param data 升序数组</span></span><br><span class="line"><span class="comment"> * @param n 数组长度</span></span><br><span class="line"><span class="comment"> * @param k 指定数字</span></span><br><span class="line"><span class="comment"> * @param start 数组的某段从start开始</span></span><br><span class="line"><span class="comment"> * @param end 数组的某段在end结束</span></span><br><span class="line"><span class="comment"> * @return 指定数字K最后一次出现的下标，数组中若没有K，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算K出现的次数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param data 升序数组</span></span><br><span class="line"><span class="comment"> * @param n 数组长度</span></span><br><span class="line"><span class="comment"> * @param k 指定数字</span></span><br><span class="line"><span class="comment"> * @return 次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumberK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> data[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; getNumberK(data, n, k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middleIndex = (start + end) &gt;&gt; <span class="number">1</span>;<span class="comment">//移位运算比算术运算快。</span></span><br><span class="line">    <span class="keyword">int</span> middleData = data[middleIndex];</span><br><span class="line">    <span class="keyword">if</span> (middleData == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((middleIndex &gt; <span class="number">0</span> &amp;&amp; data[middleIndex - <span class="number">1</span>] != k) || middleIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> middleIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = middleIndex - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middleData &gt; k) &#123;</span><br><span class="line">        end = middleIndex - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = middleIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getFirstK(data, n, k, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middleIndex = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> middleData = data[middleIndex];</span><br><span class="line">    <span class="keyword">if</span> (middleData == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((middleIndex &lt; n - <span class="number">1</span> &amp;&amp; data[middleIndex + <span class="number">1</span>] != k) || middleIndex == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> middleIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = middleIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middleData &gt; k) &#123;</span><br><span class="line">        end = middleIndex - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = middleIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getLastK(data, n, k, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumberK</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numberK = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">nullptr</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> firstIndexK = getFirstK(data, n, k, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> lastIndexK = getLastK(data, n, k, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (firstIndexK &gt; <span class="number">-1</span> &amp;&amp; lastIndexK &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            numberK = lastIndexK - firstIndexK + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numberK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;统计一个数字在排序数组中出现的次数&quot;&gt;&lt;a href=&quot;#统计一个数字在排序数组中出现的次数&quot; class=&quot;headerlink&quot; title=&quot;统计一个数字在排序数组中出现的次数&quot;&gt;&lt;/a&gt;统计一个数字在排序数组中出现的次数&lt;/h4&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="剑指Offer" scheme="http://www.readmore.ltd/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="http://www.readmore.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>观察者(Observer)模式</title>
    <link href="http://www.readmore.ltd/2018/05/02/%E8%A7%82%E5%AF%9F%E8%80%85-Observer-%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.readmore.ltd/2018/05/02/观察者-Observer-模式/</id>
    <published>2018-05-02T12:17:39.000Z</published>
    <updated>2018-05-02T12:37:21.895Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>观察者模式 — 让你的对象知悉现况<br>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p></blockquote><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p><strong>基本需求：利用WeatherData对象获取数据、并更新三个布告板：目前状况、气象统计和天气预报</strong></p><ul><li>客户有一个WeatherData对象，负责追踪温度、湿度和气压等数据。现在客户给我们提了个需求，让我们利用WeatherData对象取得数据，并更新三个布告板：目前状况、气象统计和天气预报。</li><li>WeatherData对象提供了4个接口：<ul><li><code>getTemperature()</code>：获取温度</li><li><code>getHumidity()</code>：获取湿度</li><li><code>getPressure()</code>：获取气压</li><li><code>measurementsChanged()</code>：一旦气象测量更新，此方法会被调用</li></ul></li><li>我们的工作是实现measurementsChanged()，好让它更新目前状况、气象统计、天气预报的显示布告板。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;观察者模式 — 让你的对象知悉现况&lt;br&gt;观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;提出问题&quot;&gt;&lt;a href=&quot;#提出问题&quot; 
      
    
    </summary>
    
      <category term="source" scheme="http://www.readmore.ltd/categories/source/"/>
    
    
      <category term="设计模式" scheme="http://www.readmore.ltd/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>三行情书 for Readmore</title>
    <link href="http://www.readmore.ltd/2018/05/02/%E4%B8%89%E8%A1%8C%E6%83%85%E4%B9%A6/"/>
    <id>http://www.readmore.ltd/2018/05/02/三行情书/</id>
    <published>2018-05-02T08:52:02.000Z</published>
    <updated>2018-05-02T11:20:57.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-Love-My-NightOwl"><a href="#I-Love-My-NightOwl" class="headerlink" title="I Love My NightOwl"></a>I Love My NightOwl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Liar me = <span class="keyword">new</span> Liar();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    me.say(<span class="string">"I never love you"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>给你写的第一个博客。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;I-Love-My-NightOwl&quot;&gt;&lt;a href=&quot;#I-Love-My-NightOwl&quot; class=&quot;headerlink&quot; title=&quot;I Love My NightOwl&quot;&gt;&lt;/a&gt;I Love My NightOwl&lt;/h2&gt;&lt;figure c
      
    
    </summary>
    
      <category term="Readmore" scheme="http://www.readmore.ltd/categories/Readmore/"/>
    
    
      <category term="book" scheme="http://www.readmore.ltd/tags/book/"/>
    
  </entry>
  
</feed>
